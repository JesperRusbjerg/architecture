# -*- coding: utf-8 -*-
"""Copy of Zeegu-ecosystem-Jesper-Rusbjerg.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_namTRx_O0Tbff3wDuRaMmzV2ENTMOSk
"""

# Installing Required Dependencies
import sys
sys.version
!{sys.executable} -m pip install gitpython
!{sys.executable} -m pip install pyvis

import os
cwd = os.getcwd()

CODE_ROOT_FOLDER="/content/Zeeguu-api/"



from git import Repo

if not os.path.exists(CODE_ROOT_FOLDER):
  Repo.clone_from("https://github.com/zeeguu-ecosystem/Zeeguu-API", CODE_ROOT_FOLDER)

def file_path(file_name):
    return CODE_ROOT_FOLDER+file_name

# extracting a module name from a file name
def module_name_from_file_path(full_path):
    
    file_name = full_path[len(CODE_ROOT_FOLDER):]
    file_name = file_name.replace("/__init__.py","")
    file_name = file_name.replace("/",".")
    file_name = file_name.replace(".py","")
    return file_name

import re

def import_from_line(line):
    try: 
      y = re.search("^from (\S+)", line) 
      if not y:
        y = re.search("^import (\S+)", line)      
      return y.group(1)
    except:
      return None


# extracts all the imported modules from a file
# returns a module of the form zeeguu_core.model.bookmark, e.g.
def imports_from_file(file):

    all_imports = []

    lines = [line for line in open(file)]
    
    for line in lines:
        imp = import_from_line(line)

        if imp:
            all_imports.append(imp)

    return all_imports

import pathlib
from pathlib import Path
import networkx as nx

def initial_graph():
    files = Path(CODE_ROOT_FOLDER).rglob("*.py")

    G = nx.DiGraph()

    for file in files:
        file_path = str(file)

        module_name = module_name_from_file_path(file_path)
        if module_name not in G.nodes:
            G.add_node(module_name)

        for each in imports_from_file(file_path):
            G.add_edge(module_name, each)

    return G

import matplotlib.pyplot as plt
#for pagerank
!{sys.executable} -m pip install scikit-network

def draw_graph_with_labels(G, figsize=(10,10)):
    plt.figure(figsize=figsize)
    nx.draw(G, with_labels=True, node_color='#00d4e9')
    plt.show()

!pip install kora -q
from kora import drive
drive.link_nbs()

# a filter takes an DG as input and returns another DG
def keep_nodes(inputGraph, condition):
    result = nx.DiGraph()

    for each in inputGraph.edges():
        src = each[0]
        dst = each[1]

        if (condition(src)):
          result.add_node(src)

        if (condition(dst)):
          result.add_node(dst)
          
        if (condition(src) and condition(dst)):
          result.add_edge(src, dst)
          
    return result

# a filter takes an DG as input and returns another DG
def reject_nodes(inputGraph, condition):
    result = nx.DiGraph()

    for each in inputGraph.edges():
        src = each[0]
        dst = each[1]

        if (not(condition(src))):
          result.add_node(src)

        if (not(condition(dst))):
          result.add_node(dst)
          
        if (not(condition(src)) and not(condition(dst))):
          result.add_edge(src, dst)
          
    return result

def abstract_between_levels(G, layerbot=1, layertop=0):
    aG = nx.DiGraph()
    for each in G.edges():
        src = level_module(each[0], layerbot, layertop)
        dst = level_module(each[1], layerbot, layertop)

        if src != dst:
          aG.add_edge(src, dst)
          
    return aG

def level_module(module_name, depth=1, start=0):
    #Depth must be larger than start
    components = module_name.split(".")
    return ".".join(components[start:depth])

def irelevant_module(input):
    matches = ["exercises", "test",  "constants", "configuration", "model", "exercise", "email"]
    #matches = ["exercises", "test"]
    #matches = []
    if any(x in input for x in matches):
      return True
    elif input == "zeeguu":
      return True
    elif input == "":
      return True
    else:
      return False

# we redefine the system modules
def is_system_module(m):
    return "zeegu" in m

def is_relevant_module(x):
    return "api"in x
    #return True


DG = initial_graph()
system_ADG = keep_nodes(DG, condition=is_system_module)
system_ADG = abstract_between_levels(system_ADG, 4, 2)
system_ADG = keep_nodes(system_ADG, condition=is_relevant_module)
system_ADG = reject_nodes(system_ADG, condition=irelevant_module)


draw_graph_with_labels(system_ADG, (20,20))

from IPython.display import SVG
import numpy as np
from sknetwork.data import karate_club, painters, movie_actor
from sknetwork.ranking import PageRank
from sknetwork.visualization import svg_graph, svg_digraph, svg_bigraph

pr=nx.pagerank(system_ADG)
pr

def print_commit_details(commits):
  for commit in commits:
      print(f"--->> {commit.msg}")
      print(commit.author.name)
      print(commit.author_date)
      print(commit.hash )
      print("\n")

      for each in commit.modified_files:
          print(f" {each.change_type.name}")
          print(f" - {each.old_path}")
          print(f" - {each.new_path}")
      
      print("\n\n")


# skip commit #1 - it's got too many changes to see anything here
print_commit_details(all_commits[-3:])

# what else can we know about a commit?
# in Pytho we can use the help function
help(all_commits[0])

from pydriller import ModificationType

def count_changes(commits):
    
    # a dictionary that is automatically initialized 
    # if key is absent
    from collections import defaultdict
    commit_counts = defaultdict(int)    

    for commit in commits:
        for modification in commit.modified_files:
            
            new_path = modification.new_path
            old_path = modification.old_path
            
            # try:

            if modification.change_type == ModificationType.RENAME:
                commit_counts[new_path]=commit_counts.get(old_path, 0) + 1
                
                try:
                    commit_counts.pop(old_path)
                except Exception as e:
                    # not sure why sometimes there's a rename w/o 
                    # an old_path existing?
                    # print(f"could not pop {old_path}")
                    # print(f"new path: {new_path}")
                    # print(f"commit: {commit.hash} {commit.msg}")
                    pass

            elif modification.change_type == ModificationType.DELETE:
                commit_counts.pop(old_path, '')

            elif modification.change_type == ModificationType.ADD:
                commit_counts[new_path] = 1

            else: 
                # modification to existing file
                commit_counts [old_path] += 1
            
    return sorted(commit_counts.items(), key=lambda x:x[1])

# pretty print the results
for file, count in count_changes(all_commits):
    print(f"{count} {file}")